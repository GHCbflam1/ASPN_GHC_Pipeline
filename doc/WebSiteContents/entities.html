<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Entities</title>
<link href="bootstrap.min.css" type="text/css" rel="stylesheet" />
</head>

<body>

<ul>
	<li><a href="#DocEntityClasses">Entity Classes</a></li>
	<li><a href="#DocConventionalInterfaces">Conventional Interfaces</a><ul>
		<li><a href="#DocAuditing">Auditing</a></li>
		<li><a href="#DocSoftDelete">Soft Delete</a></li>
	</ul>
	</li>
	<li><a href="#DocIEntityInterfaces">IEntity Interfaces</a></li>
</ul>

<p>Entities are one of the core concepts of DDD (Domain Driven Design). Eric
Evans describes an entity as "<em>An object that is not fundamentally defined by
its attributes, but rather by a thread of continuity and identity</em>". So,
in practice entities have Ids (identity) and are persisted in a data store
(continuity). Oftentimes an entity is mapped to a given table in a database.</p>

<h3 id="DocEntityClasses">Entity Classes</h3>
<p>In ASP.NET Boilerplate, entities are derived from the <strong>Entity</strong>
class.</p>

<pre lang="cs">public class Person : Entity
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Task()
    {
        CreationTime = DateTime.Now;
    }
}</pre>

<p>This <strong>Person</strong> class is defined as an entity and has two
properties. Additionally, due to being extended from the Entity class, the Person
class inherits an <strong>Id</strong> property which serves as the
<strong>primary key</strong>.</p>
<p>The type of Id can be modified, but defaults to an <strong>int</strong>
(Int32). If another type is desired (e.g., a long, string, or Guid), it should be
explicitly declared as seen below.</p>

<pre lang="cs">public class Person : Entity&lt;long&gt;
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Task()
    {
        CreationTime = DateTime.Now;
    }
}</pre>

<p>The Entity class overrides the <strong>equality</strong> operator (==) to
allow for equality comparison between two entities (through their Ids). The class
also defines the <strong>IsTransient()</strong> method to check if it has an
assigned Id.</p>

<h3 id="DocConventionalInterfaces">Conventional Interfaces</h3>
<p>Many applications call for entity properties to hold creation,
modification, and deletion time references. ASP.NET Boilerplate provides some
useful interfaces to make these common properties explicit and expressive.</p>

<h4 id="Doc">Auditing</h4>
<p>The <strong>IHasCreationTime</strong> interface makes it possible to use a
common property for the <strong>creation time</strong> of an entity. When
implemented, ASP.NET Boilerplate automatically sets CreationTime to the
<strong>current time</strong> when an Entity is inserted into the database.</p>

<pre lang="cs">public interface IHasCreationTime
{
   <span lang="tr"> </span>DateTime CreationTime { get; set; }
}</pre>

<p>The Person class can be re-written to implement the IHasCreationTime
interface.</p>

<pre lang="cs">public class Person : Entity&lt;long&gt;, IHasCreationTime
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Task()
    {
        CreationTime = DateTime.Now;
    }
}</pre>

<p>The <strong>ICreationAudited</strong> interface extends the functionality of
IHasCreationTime by automatically storing the ID of the user who created the
new entity.</p>

<pre lang="cs">public interface ICreationAudited : IHasCreationTime
{
    <span lang="tr">long</span> CreatorUserId { get; set; }
}</pre>

<p>You can easily implement the function of ICreationAudited by deriving
your entity from the <strong>CreationAuditedEntity</strong> class. The interface
also has a generic version to support different types for the Id property.</p>

<p>Similarly, there is a provided interface for modification time which
automatically set the property when the entity is updated.</p>

<pre lang="cs">public interface IModificationAudited
{
    DateTime LastModificationTime { get; set; }

    long LastModifierUserId { get; set; }
}</pre>

<p>If an entity requires both of these audit properties, the <strong>IAudited</strong>
interface can be implemented directly.</p>

<pre lang="cs">public interface IAudited : ICreationAudited, IModificationAudited
{

}</pre>

<p>As a shortcut it is possible to derive an entity from the
<strong>AuditedEntity</strong> class instead of implementing
<strong>IAudited</strong>. The AuditedEntity class also has a generic version to
support different types for the Id property.</p>

<h4 id="DocSoftDelete">Soft Delete</h4>
<p>Soft deleting is a commonly used pattern to mark an Entity as deleted instead
of actually deleting it from the database. For instance, it may be undesirable
to hard delete a User from the database since it has relationships with other
tables. The <strong>ISoftDelete</strong> interface should be implemented to gain
this functionality.</p>

<pre lang="cs">public interface ISoftDelete
{
    bool IsDeleted { get; set; }
}</pre>

<p>ASP.NET Boilerplate implements the soft delete pattern out-of-the-box. When a
soft-delete entity is deleted, it prevents the record from actually being
deleted and instead sets its IsDeleted property as true and updates the
entity in the database. Additionally, it will not retrieve soft deleted entities
from the database.</p>
<p>When using soft deletes it may be desirable to store data on the entity about
when it was deleted and which user deleted it. To gain this functionality,
implement the <strong>IDeletionAudited</strong> interface.</p>

<pre lang="cs">public interface IDeletionAudited : ISoftDelete
{
    long DeleterUserId { get; set; }

    DateTime DeletionTime { get; set; }
}
</pre>

<p>IDeletionAudited extends the ISoftDelete interface which means ASP.NET
Boilerplate automatically sets these properties when an entity is deleted.</p>
<p>If you want to implement all of the audit interfaces (creation, modification,
and deletion) for an entity, you can directly implement <strong>IFullAudited</strong>
since it inherits all the required interfaces.</p>

<pre lang="cs">public interface IFullAudited : IAudited, IDeletionAudited
{

}</pre>

<p>As a shortcut, entities may be derived from the <strong>FullAuditedEntity</strong>
base class.</p>
<p>NOTE: All audit interfaces and classes have a generic version for defining the
navigation property to your <strong>User</strong> entity
(e.g., ICreationAudited&lt;TUser&gt; and FullAuditedEntity&lt;TPrimaryKey, TUser&gt;).</p>

<h3 id="DocIEntityInterfaces">IEntity Interfaces</h3>
<p>The <strong>Entity</strong> class implements the <strong>IEntity</strong>
interface (and <strong>Entity&lt;TPrimaryKey&gt;</strong> implements
<strong>IEntity&lt;TPrimaryKey&gt;</strong>). If you do not want to derive from
the Entity class, you can implement these interfaces manually. This is not the
suggested method without good reason.</p>

</body>

</html>
